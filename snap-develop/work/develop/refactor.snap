import util.stream.Collectors;
import util.regex.Pattern;

var src = new File("C:\\Work\\development\\snapscript\\snap-develop\\snap-develop\\src\\main\\java");
var dest = new File("c:\\Temp\\develop");

dest.mkdirs();

src.findFiles(file -> file.isDirectory())
   .stream()
   .filter(file -> {
      var matches = file.listFiles()
         .stream()
         .filter(java -> java.name.endsWith(".java"))
         .collect(Collectors.toList());
         
      return !matches.isEmpty();
   })
   .forEach(file -> {
      var sources = file.listFiles()
         .stream()
         .filter(source -> source.name.endsWith(".java"))
         .collect(Collectors.toList());
         
      build(file, file.name, sources);       
   });
   
function build(path, name, sources){
   println("${path}: ${name} -> ${sources}");
   var prefix = new File(path.getAbsolutePath().replace("C:\\Work\\development\\snapscript\\snap-develop\\snap-develop\\src\\main\\java", "c:\\temp\\develop"));
   prefix.getParentFile().mkdirs();
   var file = new File("${prefix}.snap");
   var writer = new FileWriter(file);
   
   for(var source in sources){
      var file = new File(source).readText();
      var data = refactor(file);
      writer.write(data.source);
      writer.write("\r\n");
   }
   writer.flush();
   writer.close();
}

function refactor(source){
   return gatherImports(source);
}

function gatherImports(source){
   var builder = new StringBuilder();
   var lines = source.split("\\r?\\n");
   var imports = {};
   var type = null;
   var done = false;
   for(var line in lines){
      line = replaceTokens(line);
      if(!done){
         var importPattern = Pattern.compile("import\\s*(.*);.*");
         var typePattern = Pattern.compile(".*(class|enum|interface)\\s+(\\w+).*");
         var importMatcher = importPattern.matcher(line);
         var typeMatcher = typePattern.matcher(line);
         if(importMatcher.matches()){
            imports.add(importMatcher.group(1));
         } 
         if(typeMatcher.matches()){
            type = typeMatcher.group(2);
            builder.append(line);
            builder.append("\r\n");
            done = true;
         }
      } else {
         line = line.replace(type+"(", "new(");
         builder.append(line);
         builder.append("\r\n");
      }
   }
   var text = builder.toString();
   return new SourceFile(imports, type, text);
}

function replaceTokens(line){
   line = line.replace("public ", "");
   line = line.replace("void ", "");
   line = line.replace("@Override", "override");
   line = line.replace("throws Exception", "");
   line = line.replace("Exception e", "e");
   line = line.replace("final", "const");
   line = line.replace("implements", "with");
   line = line.replace("interface", "trait");
   line = line.replace("private class", "class");
   return line;
}

class SourceFile{
   var imports;
   var source;
   var type;
   new(imports, type, source){
      this.imports = imports;
      this.source = source;
      this.type = type;
   }
}

