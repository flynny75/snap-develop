
import android.os.Bundle;

class Model {
	
	static const TAG_DATA = "data";
	static const TAG_ACTIVE_BLOCK = "active-block";

	// some constants in the model:
	static const NUM_COLS = 10; // number of columns in field
	static const NUM_ROWS = 20; // number of rows in field

	// game status constants:
	var gameStatus = GameStatus.BEFORE_START;

	// array of cell values:
	var field;

	// active block:
	var activeBlock;

	// scores counter:
	var counter;

	new() {
		this.field = new Integer[NUM_ROWS][NUM_COLS];
	}
	
	setCounter(counter) {
		this.counter = counter;
	}

	isGameActive() {
		return GameStatus.ACTIVE == gameStatus;
	}

	isGameOver() {
		return GameStatus.OVER == gameStatus;
	}
	
	isGameBeforeStart() {
		return GameStatus.BEFORE_START == gameStatus;
	}	

	reset() {
		reset(false); // call the inner method - reset the all data
	}

	getCellStatus(nRow, nCol) {
		return field[nRow][nCol];
	}

	setCellStatus(nRow, nCol, nStatus) {
		field[nRow][nCol] = nStatus;
	}

	setGameStatus(gameStatus) {
	   synchronized(this){
		   this.gameStatus = gameStatus;
		}
	}

	// Start the game:
	gameStart() {
		if (isGameActive()) {
			return;
		}
		setGameActive();
		activeBlock = Block.createBlock();
		
	}

	setGameActive() {
		setGameStatus(GameStatus.ACTIVE);
	}
	
	setGamePaused() {
		setGameStatus(GameStatus.PAUSED);
	}

	isGamePaused() {
		return GameStatus.PAUSED.equals(gameStatus);
	}	
	
	genereteNewField(move) {	
		synchronized(this) {
   		if (!isGameActive()) {
   			return;
   		}
   
   		// get the parameters of block:
   		var newTopLeft = new Point(activeBlock.getTopLeft());
   		var nFrame = activeBlock.getFrame();
   
   		// Clear the old values:
   		reset(true);
   
   		// count new parameters:
   		switch (move) {
   		case LEFT:
   			newTopLeft.setX(newTopLeft.getX() - 1);
   			break;
   		case RIGHT:
   			newTopLeft.setX(newTopLeft.getX() + 1);
   			break;
   		case DOWN:
   			newTopLeft.setY(newTopLeft.getY() + 1);
   			break;
   		case ROTATE:
   			nFrame++;
   			if (nFrame >= activeBlock.getFramesCount())
   				nFrame = 0;
   			break;
   		}
   		if (!isMoveValid(newTopLeft, nFrame)) {
   
   			// set old the block:
   			isMoveValid(activeBlock.getTopLeft(), activeBlock.getFrame());
   
   			if (Move.DOWN.equals(move)) {
   
   				// add the scores:
   				counter.addScores();
   
   				if (!newBlock()) {
   					// Game is over
   					setGameStatus(GameStatus.OVER);
   					
   					activeBlock = null;
   					reset(false);
   				}
   			}
   
   		} else {
   			// Make the new move:
   			activeBlock.setState(nFrame, newTopLeft);
   		}
		}
	}

	// ================================================
	// Helper functions:

	/**
	 * Reset the field data:
	 * 
	 * @param true - clear only dynamic data, false - clear all the data
	 */
	reset(bDynamicDataOnly) {
		for (var i = 0; i < NUM_ROWS; i++) {
			for (var j = 0; j < NUM_COLS; j++) {
				if (!bDynamicDataOnly || field[i][j] == Block.CELL_DYNAMIC) {
					field[i][j] = Block.CELL_EMPTY;
				}
			}
		}
	}

	isMoveValid(newTopLeft, nFrame) {
		synchronized (field) {
			var shape = activeBlock.getShape(nFrame);

			if (newTopLeft.getY() < 0) {
				return false;
			}
			if (newTopLeft.getX() < 0) {
				return false;
			}
			if (newTopLeft.getY() + shape.length > NUM_ROWS) {
				return false;
			}
			if (newTopLeft.getX() + shape[0].length > NUM_COLS) {
				return false;
			}

			// Check all the items in field:
			for (var i = 0; i < shape.length; i++) {
				for (var j = 0; j < shape[i].length; j++) {
					var y = newTopLeft.getY() + i;
					var x = newTopLeft.getX() + j;
					if( Block.CELL_EMPTY!=shape[i][j] && Block.CELL_EMPTY!=field[y][x]) {
						return false;
					}
				}
			}

			// All cell is correct - add the data:
			for (var i = 0; i < shape.length; i++) {
				for (var j = 0; j < shape[i].length; j++) {
					var y = newTopLeft.getY() + i;
					var x = newTopLeft.getX() + j;
					if( Block.CELL_EMPTY!=shape[i][j]) {
						field[y][x] = shape[i][j];
					}
				}
			}
			return true;
		}
	}

	/**
	 * Create the new block:
	 * 
	 * @return true - block can be generated,
	 * @return false - can't generate the block - GAME OVER!
	 */
	newBlock() {
      synchronized(this) {
   		// set all the dynamic data as static:
   		for (var i = 0; i < field.length; i++) {
   			for (var j = 0; j < field[i].length; j++) {
   				var status = getCellStatus(i, j);
   				if (status == Block.CELL_DYNAMIC) {
   					status = activeBlock.getStaticValue();
   					setCellStatus(i, j, status);
   				}
   			}
   		}
   
   		for (var i = 0; i < field.length; i++) {
   			var bFullRow = true;
   			for (var j = 0; j < field[i].length; j++) {
   				var status = getCellStatus(i, j);
   				var isEmpty = Block.CELL_EMPTY == status;
   				bFullRow &= !isEmpty;
   			}
   			if (bFullRow) {
   				shiftRows(i);
   
   				// add lines to counter:
   				counter.addLine();
   			}
   		}
   
   		// Generate the new block:
   		activeBlock = Block.createBlock();
   
   		// Check the validity of new block:
   		if (!isMoveValid(activeBlock.getTopLeft(), activeBlock.getFrame())) {
   			// GAME IS OVER!
   			return false;
   		}
   		return true;
		}
	}

	shiftRows(nToRow) {
	   synchronized(this) {
   		if (nToRow > 0) {
   			for (var j = nToRow - 1; j >= 0; j--) {
   				for (var m = 0; m < field[j].length; m++) {
   					setCellStatus(j + 1, m, getCellStatus(j, m));
   				}
   			}
   		}
   		for (var j = 0; j < field[0].length; j++) {
   			setCellStatus(0, j, Block.CELL_EMPTY);
   		}
		}
	}

	getActiveBlockColor() {
		return activeBlock.getColor();
	}

	storeTo(bundle) {
		bundle.putSerializable(TAG_ACTIVE_BLOCK, activeBlock);
		bundle.putIntArray(TAG_DATA, getIntArrayFromData());
	}

	restoreFrom(bundle) {
		activeBlock = bundle.getSerializable(TAG_ACTIVE_BLOCK);
		restoreDataFromIntArray( bundle.getIntArray(TAG_DATA));
	}
	
	restoreDataFromIntArray(src) {
		if( null==src ) {
			return;
		}
		for( var k=0; k<src.length; k++ ) {
			var i = k / NUM_COLS;
			var j = k % NUM_COLS;
			field[i][j] = src[k];
		}
	}

	getIntArrayFromData() {
		var result = new Integer[ NUM_COLS * NUM_ROWS ];
		for( var i=0; i<NUM_ROWS; i++ ) {
			for( var j=0; j<NUM_COLS; j++ ) {
				result[ NUM_COLS * i + j ] = field[i][j];
			}
		}
		return result;
	}
	
}
